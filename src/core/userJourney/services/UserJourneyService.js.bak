'use strict';

const {
  applyRepositoryErrorHandling,
  applyServiceErrorHandling,
  applyControllerErrorHandling,
  createErrorMapper
} = require('../../../core/infra/errors/centralizedErrorUtils');

// Import domain-specific error classes
const {
  UserJourneyError,
  UserJourneyNotFoundError,
  UserJourneyValidationError,
  UserJourneyProcessingError,
} = require('../errors/UserJourneyErrors');

// Create an error mapper for services
const userJourneyServiceErrorMapper = createErrorMapper(
  {
    UserJourneyNotFoundError: UserJourneyNotFoundError,
    UserJourneyValidationError: UserJourneyValidationError,
    UserJourneyProcessingError: UserJourneyProcessingError,
    Error: UserJourneyError,
  },
  UserJourneyError
);

/**
 * User Journey Service
 *
 * Domain service for tracking and managing user journey and engagement.
 * Contains business logic for user sessions, engagement levels, and phase transitions.
 */
const { _logger } = require('../core/infra/logging/logger');
// const UserJourneyEvent = require('../models/UserJourneyEvent');
const { v4: uuidv4 } = require('uuid');
const { _userJourneyLogger } = require('../core/infra/logging/domainLogger');

/**
 * User journey phases and constants
 */
const USER_JOURNEY_PHASES = {
  ONBOARDING: 'onboarding',
  BEGINNER: 'beginner',
  INTERMEDIATE: 'intermediate',
  ADVANCED: 'advanced',
  EXPERT: 'expert',
};

/**
 * Get session timeout in milliseconds from config
 * @param {Object} config - Application configuration object
 * @returns {number} Session timeout in milliseconds
 */
const getSessionTimeoutMs = config => {
  // Default to 30 minutes if config is not provided
  const timeoutMinutes = config?.userJourney?.sessionTimeoutMinutes || 30;
  return timeoutMinutes * 60 * 1000; // Convert minutes to milliseconds
};

/**
 * Format a user event for storage
 * @param {string} userEmail - User's email
 * @param {string} eventType - Type of event
 * @param {Object} eventData - Event data
 * @param {string|null} challengeId - Optional challenge ID
 * @returns {UserJourneyEvent} Formatted event
 */
const formatUserEvent = (userEmail, eventType, eventData = {}, challengeId = null) => {
  return new UserJourneyEvent({
    id: uuidv4(),
    userEmail,
    eventType,
    eventData,
    challengeId,
    timestamp: new Date().toISOString(),
  });
};

/**
 * Calculate user engagement level from session data and recent events
 * @param {Object} journeyMeta - Journey metadata
 * @param {Array} recentEvents - Recent events
 * @returns {string} Engagement level
 */
const calculateEngagementLevel = (journeyMeta, recentEvents) => {
  if (!journeyMeta || !recentEvents) {
    return 'new';
  }

  const now = new Date();
  const lastActivity = journeyMeta.lastActivity ? new Date(journeyMeta.lastActivity) : null;

  // No previous activity
  if (!lastActivity) {
    return 'new';
  }

  // Check recency of last activity
  const daysSinceLastActivity = (now - lastActivity) / (1000 * 60 * 60 * 24);

  if (daysSinceLastActivity < 2) {
    return 'active';
  } else if (daysSinceLastActivity < 7) {
    return 'engaged';
  } else if (daysSinceLastActivity < 30) {
    return 'casual';
  } else {
    return 'inactive';
  }
};

/**
 * Determine user phase based on onboarding status and completed challenges
 * @param {Object} user - User data
 * @param {number} completedChallenges - Count of completed challenges
 * @returns {string} User phase
 */
const determineUserPhase = (user, completedChallenges) => {
  if (!user || !user.profile) {
    return USER_JOURNEY_PHASES.ONBOARDING;
  }

  // Check if user has completed profile
  const hasCompletedProfile = Boolean(user.profile.personalityTraits);

  if (!hasCompletedProfile) {
    return USER_JOURNEY_PHASES.ONBOARDING;
  }

  // Determine phase based on completed challenges
  if (completedChallenges < 5) {
    return USER_JOURNEY_PHASES.BEGINNER;
  } else if (completedChallenges < 15) {
    return USER_JOURNEY_PHASES.INTERMEDIATE;
  } else if (completedChallenges < 30) {
    return USER_JOURNEY_PHASES.ADVANCED;
  } else {
    return USER_JOURNEY_PHASES.EXPERT;
  }
};

/**
 * Generate insights and recommendations based on user's phase and engagement
 * @param {string} phase - User's current phase
 * @param {string} engagement - User's engagement level
 * @returns {Object} Insights and recommendations
 */
const generateInsightsAndRecommendations = (phase, engagement) => {
  const insights = [];
  const recommendations = [];

  // Add phase-based insights
  switch (phase) {
    case USER_JOURNEY_PHASES.ONBOARDING:
      insights.push('You are just getting started on your learning journey');
      recommendations.push('Complete your profile to get personalized challenges');
      break;
    case USER_JOURNEY_PHASES.BEGINNER:
      insights.push('You are building foundational skills');
      recommendations.push('Try different challenge types to discover your strengths');
      break;
    case USER_JOURNEY_PHASES.INTERMEDIATE:
      insights.push('You are developing deeper understanding');
      recommendations.push('Focus on your weaker areas to build a well-rounded profile');
      break;
    case USER_JOURNEY_PHASES.ADVANCED:
      insights.push('You are demonstrating advanced skills');
      recommendations.push('Challenge yourself with more difficult challenges');
      break;
    case USER_JOURNEY_PHASES.EXPERT:
      insights.push('You are operating at an expert level');
      recommendations.push('Try creating your own challenges to test your mastery');
      break;
  }

  // Add engagement-based insights
  switch (engagement) {
    case 'active':
      insights.push('You are regularly engaged with learning');
      recommendations.push('Keep up the momentum with daily challenges');
      break;
    case 'engaged':
      insights.push('You are maintaining consistent engagement');
      recommendations.push('Consider setting a schedule for more regular practice');
      break;
    case 'casual':
      insights.push('Your engagement is occasional');
      recommendations.push('Try to establish a more consistent learning routine');
      break;
    case 'inactive':
      insights.push('It has been a while since your last activity');
      recommendations.push('Start with a simple challenge to get back into practice');
      break;
  }

  return { insights, recommendations };
};

/**
 * Calculate activity metrics from challenge events
 * @param {Array} challengeEvents - Challenge completion events
 * @returns {Object} Activity metrics
 */
const calculateActivityMetrics = challengeEvents => {
  if (!challengeEvents || challengeEvents.length === 0) {
    return {
      totalChallenges: 0,
      averageScore: 0,
      streakDays: 0,
      lastChallenge: null,
    };
  }

  // Sort events by date
  const sortedEvents = [...challengeEvents].sort((a, b) => {
    return new Date(b.timestamp) - new Date(a.timestamp);
  });

  // Calculate metrics
  const lastChallenge = sortedEvents[0].timestamp;
  const scores = sortedEvents.map(event => event.data?.score).filter(Boolean);
  const averageScore =
    scores.length > 0 ? scores.reduce((sum, score) => sum + score, 0) / scores.length : 0;

  // Calculate streak days
  const _uniqueDays = new Set();
  const _streakDays = 0;

  // Sort by date ascending for streak calculation
  const datesSorted = [...challengeEvents]
    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
    .map(event => {
      const date = new Date(event.timestamp);
      return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`;
    });

  // Count consecutive days
  let currentStreak = 1;
  let maxStreak = 1;

  for (let i = 1; i < datesSorted.length; i++) {
    if (datesSorted[i] === datesSorted[i - 1]) {
      continue; // Same day, skip
    }

    const prevDate = new Date(datesSorted[i - 1]);
    const currDate = new Date(datesSorted[i]);

    // Check if dates are consecutive
    const diffTime = Math.abs(currDate - prevDate);
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

    if (diffDays === 1) {
      currentStreak++;
      maxStreak = Math.max(maxStreak, currentStreak);
    } else {
      currentStreak = 1;
    }
  }

  return {
    totalChallenges: challengeEvents.length,
    averageScore: Math.round(averageScore * 100) / 100,
    streakDays: maxStreak,
    lastChallenge,
  };
};

/**
 * Update session data and check for timeout
 * @param {Object} journeyMeta - Current journey metadata
 * @param {Date|string} currentTime - Current timestamp (Date object or ISO string)
 * @param {Object} config - Application configuration object
 * @returns {Object} Updated journey metadata
 */
const updateSessionData = (journeyMeta, currentTime = new Date(), config = null) => {
  if (!journeyMeta) {
    journeyMeta = {
      lastActivity: null,
      engagementLevel: 'new',
      sessionCount: 0,
      currentSessionStarted: null,
      currentPhase: 'onboarding',
    };
  }

  const timestamp = currentTime instanceof Date ? currentTime.toISOString() : currentTime;

  const currentDate = currentTime instanceof Date ? currentTime : new Date(currentTime);

  const lastActivityDate = journeyMeta.lastActivity ? new Date(journeyMeta.lastActivity) : null;

  // Get the session timeout value from config
  const sessionTimeoutMs = getSessionTimeoutMs(config);

  // Update session data
  // If no previous session or session timeout has occurred, start a new session
  if (
    !journeyMeta.currentSessionStarted ||
    !lastActivityDate ||
    currentDate - lastActivityDate > sessionTimeoutMs
  ) {
    journeyMeta.sessionCount = (journeyMeta.sessionCount || 0) + 1;
    journeyMeta.currentSessionStarted = timestamp;
  }

  // Always update the last activity time
  journeyMeta.lastActivity = timestamp;

  return journeyMeta;
};

module.exports = {
  formatUserEvent,
  calculateEngagementLevel,
  determineUserPhase,
  generateInsightsAndRecommendations,
  calculateActivityMetrics,
  updateSessionData,
  getSessionTimeoutMs,
};
