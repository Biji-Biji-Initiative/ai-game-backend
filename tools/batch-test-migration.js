/**
 * Batch Test Migration Script
 * 
 * This script processes multiple test files for migration or fixes based on
 * the migration plan generated by generate-migration-plan.js.
 * 
 * Usage:
 *   node tools/batch-test-migration.js --domain-fixes
 *   node tools/batch-test-migration.js --migrate-to=domain --limit=5
 *   node tools/batch-test-migration.js --all-fixes
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { execSync } from 'child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.resolve(__dirname, '..');

// Parse command line arguments
function parseArgs() {
  const args = process.argv.slice(2);
  const result = {
    migrateTo: null,
    domainFixes: false,
    integrationFixes: false,
    externalFixes: false, 
    e2eFixes: false,
    allFixes: false,
    limit: Infinity,
    dryRun: false
  };
  
  for (const arg of args) {
    if (arg.startsWith('--migrate-to=')) {
      result.migrateTo = arg.slice(13);
    } else if (arg === '--domain-fixes') {
      result.domainFixes = true;
    } else if (arg === '--integration-fixes') {
      result.integrationFixes = true;
    } else if (arg === '--external-fixes') {
      result.externalFixes = true;
    } else if (arg === '--e2e-fixes') {
      result.e2eFixes = true;
    } else if (arg === '--all-fixes') {
      result.allFixes = true;
      result.domainFixes = true;
      result.integrationFixes = true;
      result.externalFixes = true;
      result.e2eFixes = true;
    } else if (arg.startsWith('--limit=')) {
      result.limit = parseInt(arg.slice(8), 10);
      if (isNaN(result.limit)) {
        result.limit = Infinity;
      }
    } else if (arg === '--dry-run') {
      result.dryRun = true;
    }
  }
  
  return result;
}

/**
 * Load migration plan from file
 * @returns {Object} Migration plan
 */
function loadMigrationPlan() {
  const planPath = path.join(rootDir, 'test-migration-plan.md');
  
  // Check if migration plan exists
  if (!fs.existsSync(planPath)) {
    console.error('Migration plan not found. Generate it first with:');
    console.error('  node tools/generate-migration-plan.js');
    process.exit(1);
  }
  
  // Parse migration plan file to extract file paths
  const planContent = fs.readFileSync(planPath, 'utf8');
  
  // Extract file paths using regex
  const extractFileInfo = (content, section) => {
    const sectionRegex = new RegExp(`## ${section}[\\s\\S]*?###.*?\\(\\d+\\)\\s*\\n([\\s\\S]*?)(?=\\n##|$)`, 'i');
    const sectionMatch = content.match(sectionRegex);
    
    if (!sectionMatch) return [];
    
    const fileListText = sectionMatch[1];
    const fileRegex = /\*\*([^*]+)\*\*\s*→\s*([^*\n]+)/g;
    const files = [];
    let match;
    
    while ((match = fileRegex.exec(fileListText)) !== null) {
      files.push({
        path: match[1].trim(),
        action: match[2].trim()
      });
    }
    
    return files;
  };
  
  return {
    domainToMigrate: extractFileInfo(planContent, 'Domain Tests[\\s\\S]*?that should be migrated'),
    domainToFix: extractFileInfo(planContent, 'Domain Tests[\\s\\S]*?that need semantics fixes'),
    integrationToMigrate: extractFileInfo(planContent, 'Integration Tests[\\s\\S]*?that should be migrated'),
    integrationToFix: extractFileInfo(planContent, 'Integration Tests[\\s\\S]*?that need semantics fixes'),
    externalToMigrate: extractFileInfo(planContent, 'External Tests[\\s\\S]*?that should be migrated'),
    externalToFix: extractFileInfo(planContent, 'External Tests[\\s\\S]*?that need semantics fixes'),
    e2eToMigrate: extractFileInfo(planContent, 'E2E Tests[\\s\\S]*?that should be migrated'),
    e2eToFix: extractFileInfo(planContent, 'E2E Tests[\\s\\S]*?that need semantics fixes')
  };
}

/**
 * Process files based on migration plan
 */
async function processMigration() {
  const args = parseArgs();
  const plan = loadMigrationPlan();
  
  console.log('Starting batch test migration...');
  if (args.dryRun) {
    console.log('DRY RUN: No changes will be made');
  }
  
  let processedCount = 0;
  
  // Process migrations
  if (args.migrateTo) {
    console.log(`\nProcessing migrations to ${args.migrateTo} category...`);
    
    let filesToMigrate = [];
    if (args.migrateTo === 'domain') {
      filesToMigrate = [
        ...plan.integrationToMigrate.filter(f => f.action === 'migrate to domain'),
        ...plan.externalToMigrate.filter(f => f.action === 'migrate to domain'),
        ...plan.e2eToMigrate.filter(f => f.action === 'migrate to domain')
      ];
    } else if (args.migrateTo === 'integration') {
      filesToMigrate = [
        ...plan.domainToMigrate.filter(f => f.action === 'migrate to integration'),
        ...plan.externalToMigrate.filter(f => f.action === 'migrate to integration'),
        ...plan.e2eToMigrate.filter(f => f.action === 'migrate to integration')
      ];
    } else if (args.migrateTo === 'external') {
      filesToMigrate = [
        ...plan.domainToMigrate.filter(f => f.action === 'migrate to external'),
        ...plan.integrationToMigrate.filter(f => f.action === 'migrate to external'),
        ...plan.e2eToMigrate.filter(f => f.action === 'migrate to external')
      ];
    } else if (args.migrateTo === 'e2e') {
      filesToMigrate = [
        ...plan.domainToMigrate.filter(f => f.action === 'migrate to e2e'),
        ...plan.integrationToMigrate.filter(f => f.action === 'migrate to e2e'),
        ...plan.externalToMigrate.filter(f => f.action === 'migrate to e2e')
      ];
    }
    
    console.log(`Found ${filesToMigrate.length} files to migrate to ${args.migrateTo} category`);
    
    // Process migrations up to the limit
    for (const file of filesToMigrate.slice(0, args.limit)) {
      await migrateFile(file.path, args.migrateTo, args.dryRun);
      processedCount++;
    }
  }
  
  // Process fixes
  if (args.domainFixes) {
    console.log('\nProcessing domain test fixes...');
    for (const file of plan.domainToFix.slice(0, args.limit - processedCount)) {
      await fixFile(file.path, 'domain', args.dryRun);
      processedCount++;
      if (processedCount >= args.limit) break;
    }
  }
  
  if (args.integrationFixes && processedCount < args.limit) {
    console.log('\nProcessing integration test fixes...');
    for (const file of plan.integrationToFix.slice(0, args.limit - processedCount)) {
      await fixFile(file.path, 'integration', args.dryRun);
      processedCount++;
      if (processedCount >= args.limit) break;
    }
  }
  
  if (args.externalFixes && processedCount < args.limit) {
    console.log('\nProcessing external test fixes...');
    for (const file of plan.externalToFix.slice(0, args.limit - processedCount)) {
      await fixFile(file.path, 'external', args.dryRun);
      processedCount++;
      if (processedCount >= args.limit) break;
    }
  }
  
  if (args.e2eFixes && processedCount < args.limit) {
    console.log('\nProcessing E2E test fixes...');
    for (const file of plan.e2eToFix.slice(0, args.limit - processedCount)) {
      await fixFile(file.path, 'e2e', args.dryRun);
      processedCount++;
      if (processedCount >= args.limit) break;
    }
  }
  
  console.log(`\nCompleted batch migration: ${processedCount} files processed`);
  
  if (processedCount > 0 && !args.dryRun) {
    console.log('\nNext steps:');
    console.log('1. Run tests to verify functionality');
    console.log('2. Run verification tool to check semantics');
    console.log('3. Commit changes to version control');
  }
}

/**
 * Migrate a file to a different test category
 * @param {string} filePath - Path to the file
 * @param {string} targetCategory - Target category
 * @param {boolean} dryRun - If true, don't actually make changes
 */
async function migrateFile(filePath, targetCategory, dryRun) {
  const fullPath = path.join(rootDir, filePath);
  console.log(`Migrating: ${filePath} → ${targetCategory}`);
  
  if (dryRun) {
    return;
  }
  
  try {
    if (targetCategory === 'domain') {
      const cmd = `node tools/convert-to-domain-test.js --file="${fullPath}"`;
      execSync(cmd, { stdio: 'inherit' });
    } else if (targetCategory === 'e2e') {
      // Calculate destination path
      const filename = path.basename(fullPath);
      let newFilename = filename;
      if (!filename.includes('.e2e.test.js')) {
        newFilename = filename.replace('.test.js', '.e2e.test.js');
      }
      
      const testType = path.basename(path.dirname(fullPath));
      const destPath = path.join(rootDir, 'tests', 'e2e', testType, newFilename);
      
      // Create destination directory if needed
      const destDir = path.dirname(destPath);
      if (!fs.existsSync(destDir)) {
        fs.mkdirSync(destDir, { recursive: true });
      }
      
      // Copy file to e2e directory
      fs.copyFileSync(fullPath, destPath);
      console.log(`Copied to ${destPath}`);
      
      // Apply E2E fixes
      const cmd = `node tools/fix-e2e-test-semantics.js --file="${destPath}"`;
      execSync(cmd, { stdio: 'inherit' });
      
      // Delete original file
      fs.unlinkSync(fullPath);
      console.log(`Deleted original file ${fullPath}`);
    } else if (targetCategory === 'integration') {
      // Calculate destination path
      const filename = path.basename(fullPath);
      const testType = path.basename(path.dirname(fullPath));
      const destPath = path.join(rootDir, 'tests', 'integration', testType, filename);
      
      // Create destination directory if needed
      const destDir = path.dirname(destPath);
      if (!fs.existsSync(destDir)) {
        fs.mkdirSync(destDir, { recursive: true });
      }
      
      // Move file to integration directory
      fs.copyFileSync(fullPath, destPath);
      fs.unlinkSync(fullPath);
      console.log(`Moved to ${destPath}`);
      
      // Update description to include "Integration:"
      let content = fs.readFileSync(destPath, 'utf8');
      content = content.replace(
        /describe\(['"]([^'"]*)['"]/g,
        (match, description) => {
          if (!description.startsWith('Integration:')) {
            return `describe('Integration: ${description}'`;
          }
          return match;
        }
      );
      fs.writeFileSync(destPath, content);
    } else if (targetCategory === 'external') {
      // Calculate destination path
      const filename = path.basename(fullPath);
      const externalType = filePath.includes('openai') ? 'openai' : 'supabase';
      const destPath = path.join(rootDir, 'tests', 'external', externalType, filename);
      
      // Create destination directory if needed
      const destDir = path.dirname(destPath);
      if (!fs.existsSync(destDir)) {
        fs.mkdirSync(destDir, { recursive: true });
      }
      
      // Move file to external directory
      fs.copyFileSync(fullPath, destPath);
      fs.unlinkSync(fullPath);
      console.log(`Moved to ${destPath}`);
      
      // Update description to include "External:"
      let content = fs.readFileSync(destPath, 'utf8');
      content = content.replace(
        /describe\(['"]([^'"]*)['"]/g,
        (match, description) => {
          if (!description.startsWith('External:')) {
            return `describe('External: ${description}'`;
          }
          return match;
        }
      );
      
      // Add skipIfMissingEnv if missing
      if (!content.includes('skipIfMissingEnv')) {
        content = content.replace(
          /before\(function\s*\(\)\s*\{/,
          `before(function() {\n    skipIfMissingEnv(this, '${externalType}');`
        );
      }
      
      fs.writeFileSync(destPath, content);
    }
  } catch (error) {
    console.error(`Error migrating ${filePath}:`, error.message);
  }
}

/**
 * Fix semantics issues in a test file
 * @param {string} filePath - Path to the file
 * @param {string} category - Test category
 * @param {boolean} dryRun - If true, don't actually make changes
 */
async function fixFile(filePath, category, dryRun) {
  const fullPath = path.join(rootDir, filePath);
  console.log(`Fixing semantics: ${filePath}`);
  
  if (dryRun) {
    return;
  }
  
  try {
    if (category === 'domain') {
      // Fix domain test semantics
      const content = fs.readFileSync(fullPath, 'utf8');
      let updatedContent = content;
      
      // 1. Make sure it's using Sinon
      if (!updatedContent.includes('import sinon')) {
        updatedContent = updatedContent.replace(
          /import \{([^}]*)\} from "chai";/,
          'import { $1 } from "chai";\nimport sinon from "sinon";'
        );
      }
      
      // 2. Add sandbox setup if missing
      if (!updatedContent.includes('sinon.createSandbox')) {
        updatedContent = updatedContent.replace(
          /describe.*?\{/,
          '$&\n' +
          '  let sandbox;\n' +
          '  \n' +
          '  beforeEach(function() {\n' +
          '    sandbox = sinon.createSandbox();\n' +
          '  });\n' +
          '  \n' +
          '  afterEach(function() {\n' +
          '    sandbox.restore();\n' +
          '  });\n'
        );
      }
      
      // 3. Make sure it uses in-memory storage if checking for repository
      if (updatedContent.includes('Repository') && !updatedContent.includes('new Map()')) {
        const beforeEachPos = updatedContent.indexOf('beforeEach(function');
        if (beforeEachPos !== -1) {
          const beforeEachEnd = updatedContent.indexOf('});', beforeEachPos) + 3;
          updatedContent = 
            updatedContent.slice(0, beforeEachEnd) + 
            '\n  // In-memory repository storage\n' +
            '  const repositoryData = new Map();\n' +
            updatedContent.slice(beforeEachEnd);
        }
      }
      
      // 4. Remove any real Supabase/OpenAI client creation
      updatedContent = updatedContent.replace(
        /const supabaseClient = createClient\([^)]+\);/g,
        '// Using in-memory storage instead of real Supabase\n' +
        '    const mockData = new Map();'
      );
      
      updatedContent = updatedContent.replace(
        /const openaiClient = new OpenAIClient\([^)]+\);/g,
        'const openaiClient = {\n' +
        '      responses: {\n' +
        '        create: sandbox.stub().resolves({\n' +
        '          choices: [{ message: { content: \'{"success": true}\' } }]\n' +
        '        })\n' +
        '      }\n' +
        '    };'
      );
      
      // 5. Ensure test description starts with "Domain:"
      updatedContent = updatedContent.replace(
        /describe\(['"]([^'"]*)['"]/g,
        (match, description) => {
          if (!description.startsWith('Domain:')) {
            return `describe('Domain: ${description}'`;
          }
          return match;
        }
      );
      
      if (updatedContent !== content) {
        fs.writeFileSync(fullPath, updatedContent);
        console.log(`Updated domain test semantics in ${filePath}`);
      } else {
        console.log(`No changes needed for ${filePath}`);
      }
    } else if (category === 'e2e') {
      // Use the E2E fix script for E2E tests
      const cmd = `node tools/fix-e2e-test-semantics.js --file="${fullPath}"`;
      execSync(cmd, { stdio: 'inherit' });
    } else if (category === 'integration') {
      // Fix integration test semantics
      const content = fs.readFileSync(fullPath, 'utf8');
      let updatedContent = content;
      
      // 1. Ensure test description starts with "Integration:"
      updatedContent = updatedContent.replace(
        /describe\(['"]([^'"]*)['"]/g,
        (match, description) => {
          if (!description.startsWith('Integration:')) {
            return `describe('Integration: ${description}'`;
          }
          return match;
        }
      );
      
      // 2. Remove API calls if present
      if (updatedContent.includes('apiTestHelper.api')) {
        console.log(`WARNING: ${filePath} contains API calls which should be removed manually`);
      }
      
      if (updatedContent !== content) {
        fs.writeFileSync(fullPath, updatedContent);
        console.log(`Updated integration test semantics in ${filePath}`);
      } else {
        console.log(`No changes needed for ${filePath}`);
      }
    } else if (category === 'external') {
      // Fix external test semantics
      const content = fs.readFileSync(fullPath, 'utf8');
      let updatedContent = content;
      
      // 1. Ensure test description starts with "External:"
      updatedContent = updatedContent.replace(
        /describe\(['"]([^'"]*)['"]/g,
        (match, description) => {
          if (!description.startsWith('External:')) {
            return `describe('External: ${description}'`;
          }
          return match;
        }
      );
      
      // 2. Add skipIfMissingEnv if missing
      const externalType = filePath.includes('openai') ? 'openai' : 'supabase';
      if (!updatedContent.includes('skipIfMissingEnv')) {
        updatedContent = updatedContent.replace(
          /before\(function\s*\(\)\s*\{/,
          `before(function() {\n    skipIfMissingEnv(this, '${externalType}');`
        );
      }
      
      if (updatedContent !== content) {
        fs.writeFileSync(fullPath, updatedContent);
        console.log(`Updated external test semantics in ${filePath}`);
      } else {
        console.log(`No changes needed for ${filePath}`);
      }
    }
  } catch (error) {
    console.error(`Error fixing semantics in ${filePath}:`, error.message);
  }
}

// Run the script
processMigration(); 